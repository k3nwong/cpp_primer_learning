# 第二章 变量和基本类型
## 2.1 基本内置类型
### 2.1.1 算术类型
算术类型的尺寸再不同机器上不同。下表是C++标准规定的尺寸的最小值。
| 类型 | 含义 | 最小尺寸 | 备注 |
| :--: | :--: | :--: | :--: |
| `bool` | 布尔类型 | 未定义 |  |
| `char` | 字符 | 8位 | 一个`char`的大小和一个机器字节一样 |
| `wchar_t` | 宽字符 | 16位 | 拓展字符集 |
| `char16_t` | Unicode字符 | 16位 | 拓展字符集（Unicode） |
| `char32_t` | Unicode字符 | 32位 | 拓展字符集（Unicode） |
| `short` | 短整型 | 16位 |  |
| `int` | 整型 | 16位 |  |
| `long` | 长整型 | 32位 |  |
| `long long` | 长整型 | 64位 |  | 
| `float` | 单精度浮点数 | 6位有效数字 |  |
| `double` | 双精度浮点数 | 10位有效数字 |  |
| `long double` | 拓展精度浮点数 | 10位有效数字 |  |


#### 带符号类型和无符号类型
除去布尔型和扩展的字符型之外，其他整型可以划分为 **带符号的** 和 **无符号的** 两种，从而可以表示正数、负数或0。  

类型 `int`、`short`、`long` 和 `long long` 都是带符号的，无符号类型需再类型名前加上 `unsigned`。类型 `unsigned int` 可以缩写成 `unsigned`。  

字符型有三种类型：`char`、`signed char`、`unsigned char`。类型 `char` 实际上会表现为上述两种形式中的一种（由编译器决定）。


### 2.1.2 字面值常量
#### 2.1.2.1 整型和浮点型字面值

#### 2.1.2.2 字符和字符串字面量  
由单引号括起来的一个字符称为`char`型字面量，双引号括起来的零个或多个字符则构成字符串型字面量。

#### 2.1.2.3 转义序列  
| 符号 | 含义 |
| :-: | :-: |
| `\n` | 换行符 |
| `\t` | 横向制表符 |
| `\a` | 报警（响铃）符 |
| `\v` | 纵向制表符 || `\b` | 退格符 |
| `\"` | 双引号 |
| `\\` | 反斜线 |
| `\?` | 问号 |
| `\'` | 单引号符 |
| `\r` | 回车符 |
| `\f` | 进纸（转页）符 |

> 泛化的转义序列  
其形式是`\x`后紧跟一个或多个十六进制数字，或者`\`后紧跟一个、两个或三个八进制数字，其中数字部分表示的是字符对应的数值。  
如：`\7（响铃）`、`\40（空格）`、`\115（字符M）`  
需注意的是如果反斜线`\`后面跟着的八进制数字超过3个，只有前3个数字与`\`构成转义序列。

#### 2.1.2.4 指定字面量的类型
通过添加前缀和后缀，可以改变整型、浮点型和字符型字面量的默认类型。

- 字符和字符串字面值  
  | 前缀 | 含义 | 类型 |
  | :-: | :-: | :-: |
  | `u` | `Unicode`16字符 | `char16_t` |
  | `U` | `Unicode`32字符 | `char32_t` |
  | `L` | 宽字符 | `wchar_t` |
  | `u8` | `UTF-8`(仅用于字符串字面常量) | char |

- 整型字面值
  | 后缀 | 最小匹配类型 |
  | :-: | :-: |
  | `u/U` | `unsigned` |
  | `l/L` | `long` |
  | `ll/LL` | `long long` | 

- 浮点型字面值
  | 后缀 | 类型 |
  | `f/F` | `float` |
  | `l/L` | `long double` |


## 2.2 变量
### 2.2.1 列表初始化
用花括号来初始化变量的形式被称为 **列表初始化**。例如`int sold = {0}`和`int sold{0}`。  

当用于内置类型的变量时，如果我们使用列表初始化存在丢失信息的风险时，编译器将报错：
```c++
long double ld = 3.1415926536;
int a{ld}, b = {ld};//error
int c(ld), d = ld;//works
```
上述情况，使用`long double`的值初始化`int`变量时可能丢失数据，所以编译器拒绝了`a`和`b`的初始化请求。

### 2.2.2 变量声明和定义的关系
**声明** 使得名字为程序所知，一个文件如果想使用别处定义的名字必须包含对那个名字的声明。

**定义** 负责创建与名字关联的实体。  

变量声明规定了变量的类型和名字，定义也一样。但是定义还能申请存储空间，也可能会为变量赋一个初始值。  

如果想声明一个变量而非定义它，就在变量名前添加关键字`extern`，而且不要显示地初始化变量：
```c++
extern int i; //declaration
int j; //definition
extern double pi = 3.14159; //defintion
```
在函数体内部，如果试图初始化一个由`extern`关键字标记的变量，将会引发错误。
> !!!变量能且只能被定义依次，但是可以被多次声明。

### 2.2.3 标识符
注意保留字

### 2.2.4 名字的作用域
- 全局作用域
- 块作用域
- 嵌套作用域：内层作用域、外层作用域


## 2.3 复合类型
**复合类型** 是指基于其他类型定义的类型。  

### 2.3.1 引用
**引用** 为对象起了另外一个名字，引用类型引用另外一种类型，通过声明符写成`&d`的形式来定义引用类型，其中`d`是声明的变量名。需注意的是 **①引用必须初始化，且初始值必须是一个匹配的对象** ！ **②使用与初始值是绑定在一起的，可理解为该变量的别名** 。 **③一位引用本身不是一个对象，所以不能定义引用的引用** 。
```c++
int ival = 1024;
int &refVal = ival;
int &refVal2; //error
```

### 2.3.2 指针
**指针** 是“指向”另外一种类型的复合类型。指针有以下特点：
- 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的声明周期内它可以先后指向几个不同的对象
- 指针无需在定义时赋初值。  

定义指针类型的方法将声明符写成`*d` 的形式，其中`d`是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号`*`。

#### 2.3.2.1 获取对象的指针
指针存放某个对象的地址，获取该地址需要使用 **取地址符（操作符`&`）**

#### 2.3.2.2 指针值
指针的值（即地址）应属下面4种状态之一：
1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，意味着指针没有指向任何对象
4. 无效指针（上述情况外的其他值）

#### 2.3.2.3 利用指针访问对象
如果指针指向了一个对象，则可以使用 **解引用符（操作符`*`）** 来访问对象

#### 2.3.2.4 空指针
空指针不指向任何对象。下面是生成空指针的几种方法：
```c++
int *p1 = nullptr;//recommand
int *p2 = 0;//需要 #include <cstdlib>
int *p3 = NULL;
```
#### 2.3.2.5 赋值和指针
给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。

#### 2.3.2.6 void* 指针
`void*`是一种特殊的指针类型，可用于存放 **任意对象** 的地址。一个`void*`指针存放着一个地址，但对于该地址中的对象是什么类型并不了解。所以不能直接操作`void*`指针所指的对象，没法访问内存空间中所存的对象。  

利用`void*`指针的事情比较有限：
- 与其他指针比较
- 作为函数的输入或输出
- 赋给另一个`void*`指针


### 2.3.3 理解符合类型的声明
#### 2.3.3.1 定义多个变量
涉及到指针或引用的声明，一般有两种写法。
- 把修饰符和变量标识符写在一起。这种形式着重强调变量具有的复合类型。  
  `int *p1, *p2;`
- 把修饰符和类型名写在一起，并且每条语句只定义一个变量。这种形式着重强调本次声明只定义了一种复合类型。  
  ```c++
  int* p1;
  int* p2;
  ```

#### 2.3.3.2 指向指针的指针
通过`*`的个数可以区分指针的级别。

#### 2.3.3.3 指向指针的引用
面对一条比较复杂的指针或引用的声明语句，从右向左阅读有助于弄清楚它的真实含义。（离变量名最近的符号对变量的类型有最直接的影响。）


## 2.4 const 限定符
关键字`const`对变量的类型进行限定可以使该变量的值不能被改变。因为`const`对象一旦创建后其值就不能再改变，所以`const`对象必须初始化。

默认情况下，`const`对象仅在文件内有效。如果想要`const`变量再文件间共享，则可以通过添加关键字`extern`来实现。

### 2.4.1 const 的引用
可以把引用绑定到`const`对象上（对常量的引用），对常量的引用不能用作修改它绑定的对象。

#### 2.4.1.1 初始化和对 const 的引用
一般情况下，引用的类型必须与其所引用的对象的类型一致，但是有两个例外。第一种例外情况就是： **在初始化变量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。** 尤其，允许一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式：
```c++
double dval = 3.14;
const int &ri = dval;
```
编译器执行上述代码时，会产生一个临时量对象来处理类型转换。
```c++
const int temp = dval;
const int &ri = temp;
```

#### 2.4.1.2 对 const 的引用可能引用一个并非const的对象
常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值。

### 2.4.2 指针和 const
**指向常量的指针** 不能用于改变其所指对象的值。想要存放常量对象的地址，只能使用指向常量的指针。但指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

一般情况下，指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是 **允许令一个指向常量的指针指向一个非常量对象**。

#### 2.4.2.1 const 指针
`const pointer`必须初始化，一旦初始化完成，则它的值（存放在指针中的地址）就不能改变了。把`*`放在`const`关键字之前用以说说明指针是一个常量，这样的书写形式意味着，不变的是指针本身的值而非指向的那个值。


### 2.4.3 顶层 const
**顶层`const`** 表示指针本身是个变量，**底层`const`** 表示指针所指的对象是一个常量。  
一般地来说，**顶层`const`** 可以表示任意的对象是常量，而 **底层`const`** 则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层`const`也可以是底层`const`。
```c++
int i = 0;
int *const p1 = &i;//顶层const,指针指向的内存地址不能改变，但是其内容可以改变
const int ci = 42;//顶层const，不能改变ci的值
const int *p2 = &ci;//底层const，指针指向的内容不可改变，但可以改变指针的指向
const int *const p3 = p2;//靠右的const是顶层const，靠左的是底层const，指针指向的内存地址和指针指向的内容均不可改变
const int &r = ci;//用于声明引用的const都是底层const
```
> ？？？粗浅的理解：底层`const`使指向的对象的内容不能改变，顶层`const`使对象本身不能改变？

当执行对象的拷贝操作时，常量是顶层`const`还是底层`const`区别明显，顶层`const`不受影响，而对于底层`const`来说，拷入和拷出的对象必须 **具有相同的底层`const`资格** ，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。
```c++
int *p = p3;//error，p3包含底层const的定义，而p没有
p2 = p3;//works，p2和p3都是底层const
p2 = &i;//works，int*能转化成const int*
int &i = ci;//error，普通的int&不能绑定到int常量上
const int &r2 = i;//works，const int&可以绑定到一个普通的int上
```

### 2.4.4 constexpr 和常量表达式
**常量表达式** 是指值不会改变并且在编译过程就能得到计算结果的表达式。

#### 2.4.4.1 constexpr 常量
c++新标准规定，允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式。声明为`constexpr`的变量一定是一个常量，而且必须用常量表达式初始化。

#### 2.4.4.2 字面值类型
一些类型比较简单，值也显而易见、容易得到，就把它们称为"字面值类型"。算术类型、引用和指针都属于字面值类型。

指针和引用定义成`constexpr`的初始值收到严格限制。一个`constexpr`指针的初始值必须是`nullptr`或者`0`，或者是存储于某个固定地址中的对象（`constexpr`引用）。

#### 2.4.4.3 指针和`constexpr`
在`constexpr`声明中定义了一个指针，限定符`constexpr`仅对指针有效，与指针所指的的对象无关，`constexpr`把它所定义的对象置为了顶层`const`：
```c++
const int *p = nullptr; //p是一个指向整型常量的指针
constexpr int *q = nullptr; //p是一个指向整数的常量指针
```
与其他指针类似，`constexpr`指针既可以指向常量也可以指向一个非常量。


## 2.5 处理类型
### 2.5.1 类型别名
类型别名是一个名字，它是某种类型的同义词。适用类型别名可以让复杂的类型名字简单化，易于理解和使用。有两种方法可以定义类型别名：
- 使用关键字`typedef`  
  ```c++
  typedef double wages; //wages是double的同义词
  typedef wages base, *p; //base是都变了的同义词，p是 double* 的同义词
  ```

- 使用 **别名声明** 来定义类型的别名（c++新标准）  
  这种方法用关键字`using`作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成右侧类型的别名。
  ```c++
  using SI = Sales_item; //SI是Sales_item的同义词
  ```

#### 2.5.1.1 指针、常量和类型别名
如果某个类型别名指代的是符合类型或常量，那么把它用到声明语句里可能会产生歧义，例如：
```c++
typedef char *pstring;
const pstring cstr = 0;//cstr是指向char的常量指针
const pstring *ps;//ps是一个指针，它的对象是指向char的常量指针
```
应该整体理解别名而不是带入重写语句进行理解！！！

### 2.5.2 auto 类型说明符
c++新标准引入了`auto`类型说明符，用它能让编译器替我们去分析表达式所属的类型。`auto`定义的变量必须有初始值。

#### 2.5.2.1 复合类型、常量和 auto
- 当引用被作为初始值时，编译器以引用对象的类型作为`auto`的类型
- `auto`一般会忽略掉顶层`const`，同时底层`const`会保留下来
- 如果希望别推断出的`auto`类型是一个顶层`const`，需要明确指出：`const auto f = ci;`
- 设置一个类型为`auto`的引用时，初始值中的顶层变量属性仍然被保留。如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。

### 2.5.3 decltype 类型指示符
c++新标准引入了`decltype`类型符，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。  

如果`decltype`使用的表达式是一个变量，则`decltype`返回该变量的类型（包括顶层`const`和引用在内）：
```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x的类型是const int
decltype(cj) y = x; // y的类型是const int&，y绑定到变量x
decltype(cj) z;  // error：z是一个引用，必须初始化
```

#### 2.5.3.1 decltype 和引用
如果`decltype`使用的表达式不是一个常量，则`decltype`返回表达式结果对应的类型。 

如果表达式的内容是解引用操作(`*`)，则`decltype`将得到引用类型。  

对于`decltype`所用的表达式来说，如果变量名加上了一层或者多层括号，编译器会把它当成一个表达式，从而得到引用类型；如果`decltype`使用的是一个不加括号的变量，则得到的结果就是该变量的类型。


# 第三章 字符串、向量和数组
## 3.1 命名空间的using声明
使用`using`声明可以直接访问命名空间的名字。

## 3.2 标准库类型string
标准库类型`string`表示可边长的字符序列，使用`string`类型必须首先包含`string`头文件。作为标准库的一部分，`string`定义在命名空间`std`中。

### 3.2.1 定义和初始化string对象
下面是初始化对象常用的一些方式：
| 初始化方式 | 说明 |
| :--: | :--: |
| `string s1` | 默认初始化，`s1`是一个空字符串 |
| `string s2(s1)` | `s2`是`s1`的副本 |
| `string s2 = s1` | 等价于`s2(s1)`，`s2`是`s1`的副本 |
| `string s3("value")` | `s3`是字面值`"value"`的副本，除了字面值最后的那个那个空字符外 |
| `string s3 = "value"` | 等价于`s3("value")`，`s3`是字面值`"value"`的副本 |
| `string s4(n,'c')` | 把`s4`初始化为由连续`n`个字符`c`组成的串 |

### 3.2.1.1 直接初始化和拷贝初始化
如果使用等号（`=`）初始化一个变量，实际上执行的是 **拷贝初始化** ，编译器将等号右边的初始值拷贝到新创建的对象中去。如果不使用等号，则执行的是 **直接初始化**。

### 3.2.2 string对象上的操作
下面是string的部分常用操作：
| 操作 | 含义 |
| :-: | :-: |
| `os << s` | 将`s`写到输出流`os`当中，返回`os` |
| `is >> s`  | 从`is`中读取字符串赋给`s`，字符串以空白分隔，返回`is` | 
| `getline(is, s)` | 从`is`中读取一行赋给`s`，返回`is` |
| `s.empty()` | `s`为空返回`true`，否则返回`false` |
| `s.size()` | 返回`s`中的字符的个数 |
| `s[n]` | 返回`s`中第`n`个字符的引用，位置从`0`计起 |
| `s1 + s2` | 返回`s1`和`s2`连接后的结果 |
| `s1 = s2` | 用`s2`的副本代替`s1`中原来的字符 |
| `s1 == s2` | 如果`s1`和`s2`中所含的字符完全一样，则它们相等，`string`对象的相等性判断对字母的大小写敏感 |
|  `s1 != s2` | 判断`s1`和`s2`中所含的字符是否不等 |
| `<, <=, >, >=` | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感 |

#### 3.2.2.1 读写string对象
执行读取操作时，`string`对象会自动忽略开头的空白，并从第一个真正的字符开始读起，知道遇见下一个空白为止。

#### 3.2.2.2 使用getline读取一整行
`getline`函数的参数是一个输入流和一个`string`对象，函数从给定的输入流中读入内容，知道遇到换行符为止（换行符被读入），然后把所读的内容存入`string`对象中（不存换行符）。

#### 3.2.2.3 string::size_type 类型
`size`函数返回的是一个`string::size_type`类型的值，且是一个 **无符号** 类型的值，

#### 3.2.2.4 比较string对象
`string`对象相等表示它们的长度相同而且所包含的字符也全都相同。  

关系运算符依照（大小写敏感的）字典顺序：
- 如果两个`string`对象的长度不同，而且较短`string`对象的每个字符都与较长`string`对象对应位置上的字符相同，较短`string`对象小于较长`string`对象
- 如果两个`string`对象在某些对应的位置上不一致，则`string`对象比较的结果其实是`string`对象中第一对相异字符比较的结果

#### 3.2.2.5 string对象相加
对`string`对象使用`+`的结果是一个新的`string`对象。复合赋值运算符（`+=`）负责把右侧的`string`对象添加到左侧`string`对象的后面

#### 3.2.2.6 字面值和string对象相加
当`string`对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个`+`的两侧运算对象至少有一个是`string`对象。
```c++
string s1 = "hello" + ",";//error
```

### 3.2.3 处理string对象中的字符
在`cctype`头文件中定义了一组标准函数处理判断字符特性：
| 函数 | 说明 | 
| :--: | :--: |
| `isalnum(c)` | 当`c`是字母或者数字时为真 |
| `isalpha(c)` | 当`c`是字母时为真 |
| `iscntrl(c)` | 当`c`是控制字符时为真 |
| `isdigit(c)` | 当`c`是数字时为真 |
| `isgraph(c)` | 当`c`不是空格但可打印时为真 |
| `islower(c)` | 当`c`是小写字母时为真 |
| `isprint(c)` | 当`c`是可打印字符时为真（即`c`是空格或`c`具有可视形式） |
| `ispunct(c)` | 当`c`是标点符号时为真 |
| `isspace(c)` | 当`c`是空白时为真 |
| `isupper(c)` | 当`c`是大写字母时为真 |
| `isxdigit(c)` | 当`c`是十六进制数字时为真 |
| `tolower(c)` | 输出`c`对应的小写字母 |
| `toupper(c)` | 输出`c`对应的大写字母 |

#### 3.2.3.1 处理每个字符？使用基于范围的for语句
范围`for`语句，这种语句遍历给定顶序列中的每个元素对序列中的每个值执行某种操作，其语法形式是：
```c++
for (declaration : expression)
    statement
```

#### 3.2.3.2 利用范围for语句改变字符串中的字符
如果要改变string对象中的字符的值，必须把循环变量定义成引用类型。

#### 3.2.3.2 利用下标进行迭代
```c++
string s("some string")
for (decltype(s.size()) index = 0; index != s.size() && !isspace(s[index]); ++index)   s[index] = toupper(s[index]);
```

> 使用下标时必须确保其在合理范围之内，一种简便易行的方法是，总是设下表的类型为`string::size_type`，因为此类型是无符号数，可以确保下标不会小于0。此时，代码只需保证下标小于`size()`的值就可以了。


## 3.3 标准库类型vector
标准库类型`vector`（容器）表示 **对象** 的集合，其中所有对象的类型都相同。集合中每个对象都有一个与之对应的索引用于访问对象。  

要使用`vector`必须包含适当的头文件和`using`声明：
```cpp
#include <vector>
using std::vector;
```

### 3.3.1 定义和初始化vector对象
下面是初始化`vector`对象的方法：
| 初始化方式 | 说明 |
| :-: | :-: |
| `vector<T> v1` | `v1`是一个空`vector`，它的潜在的元素是`T`类型的，执行默认初始化 |
| `vector<T> v2(v1)` | `v2`中包含有`v1`所有元素的副本 |
| `vector<T> v2 = v1` | 等价于`vector<T> v2(v1)` |
| `vector<T> v3(n, val)` | `v3`包含了`n`个重复的元素，每个元素的值都是`val` |
| `vector<T> v4(n)` | `v4`包含了`n`个重复地执行了值初始化的对象 |
| `vector<T> v5{a,b,c...}` | `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值 |
| `vector<T> v5 = {a,b,c...}` | 等价于`vector<T> v5{a,b,c...}` |

### 3.3.2 向vector对象中添加元素
`C++`标准要求`vector`能在运行时高效快速地添加元素：先创建一个空`vector`，然后在运行时利用`push_back()`函数向其中添加元素。`push_back`负责把一个值当成`vector`对象的为元素压到`vector`对象的尾端。

### 3.3.3 其他vector操作
下面是`vector`支持的一些操作：
| 表达式 | 说明 |
| :-: | :-: |
| `v.empty()` | 如果`v`不含有任何元素，返回真；否则返回假 |
| `v.size()` | 返回`v`中元素的个数 |
| `v.push_back()` | 向`v`的尾端添加一个值为`t`的元素 |
| `v[n]` | 返回`v`中第`n`个位置上元素的引用 |
| `v1 = v2` | 用`v2`元素的拷贝替换`v1`中的元素 |
| `v1 = {a,b,c...}` | 用列表中的元素的拷贝替换`v1`中的元素 |
| `v1 == v2` | `v1`和`v2`相等当且仅当它们的元素数量相同且对应为止的元素值都相同 |
| `v1 != v2` | `v1`和`v2`不相等时返回真 |
| `<, <=, >, >=` | 以字典顺序进行比较 |

> 要使用`size_type`，需首先指定它是由哪种类型定义的。`vector`对象的类型总是包含着元素的类型：
> ```cpp
> vector<int>::size_type //正确
> vector::size_type //错误
> ```

#### 3.3.3.1 不能用下标形式添加vector元素
`vector`对象(以及`string`对象)的下标运算符可用于访问已存在的元素，但不能用于添加元素。


## 3.4 迭代器介绍
### 3.4.1 使用迭代器
有迭代器的类型同时拥有返回迭代器的成员，比如，这些类型都拥有名为 `begin` 和 `end`的成员，其中`begin`成员负责返回指向第一个元素（或第一个字符）的迭代器，`end`成员则负责返回指向容器（或`string`对象）为元素的下一位置的迭代器（**尾后迭代器**）。  

如果容器为空，则`begin`和`end`返回的是同一个迭代器，都是尾后迭代器。一般来说用`auto`关键词定义`begin`和`end`的返回值类型。

#### 3.4.1.1 迭代器运算符
下面是标准容器迭代器的运算符：
| 运算符 | 说明 |
| :-: | :-: |
| `*iter` | 返回迭代器`iter`所指元素的 **引用** |
| `iter->mem` | 解引用`iter`并获取该元素名为`mem`的成员，等价于`(*iter).mem` |
| `++iter` | 令`iter`指向容器中的下一个元素 |
| `--iter` | 令`iter`指向容器中的上一个元素 |
| `iter1 == iter2` | 判断两个迭代器是否相等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则它们相等，否则说这两个迭代器不相等。   |
| `iter != iter2` | 判断两个迭代器是否不相等 |

#### 3.4.1.2 迭代器类型
一般来说我们无需知道迭代器的精确类型，拥有迭代器的标准库类型使用`iterator`和`const_iterator`来表示迭代器的类型：
```cpp
vector<int>::iterator it;//it能读写vector<int>的元素
string::iterator it2;//it2能读写string对象中的字符

vector<int>::const_iterator it3;//it3只能读元素，不能写元素
string::const_iterator it4;//it4只能读元素，不能写元素
```
`const_iterator`能读取但不能修改它所指的元素值，`iterator`的对象可读可写。如果`vector`对象或`string`对象是一个常量，那么只能使用`const_iterator`;如果`vector`对象或`string`对象步是一个常量，那么既能使用`const_iterator`又能使用`iterator`。

####  3.4.1.3 begin和end运算符
`begin`和`end`返回的具体类型由对象是否是常量决定，如果对象是常量，返回`const_iterator`,如果对象不是常量，返回`iterator`。  

为了便于专门得到`const_iterator`类型的返回值，`C++`新标准引入了两个新函数`cbegin`和`cend`，分别返回指示容器第一个元素或最后元素的下一位置的迭代器。上述两个函数无论`vector`对象（或`string`对象）本身是否是常量，返回值都是`const_iterator`。

#### 3.4.1.4 结合解引用和成员访问操作
解引用迭代器可获得迭代器所指的对象，如果该对象的类型是类，则有可能进一步访问它的成员。`C++`定义了箭头运算符（`->`），箭头运算符把解引用和成员访问两个操作结合在一起。

#### 3.4.1.5 某些对vector对象的操作会使迭代器失效
任何一种改变可能改变`vector`对象容量的操作，比如`push_back`，都会使该`vector`对象的迭代器失效。
> 凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。

### 3.4.1 迭代器运算
下面是`vector`和`string`迭代器支持的运算：  
| 运算 | 说明 |
| :-: | :-: |
| `iter + n` | 迭代器加上一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置 |
| `iter - n` | 迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置 |
| `iter1 += n` | 迭代器加法的复合赋值语句，将`iter1`加`n`的结果赋给`iter1` |
| `iter1 -= n` | 迭代器减法的复合赋值语句，将`iter1`减`n`的结果赋给`iter1` |
| `iter1 - iter2` | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到坐标的迭代器，参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置 |
| `>、>=、<、<=` | 迭代器的关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。参与运算的两个迭代器必须指向的是同一个容器中那个的元素或者尾元素的下一个位置 |

#### 3.4.1.1 迭代器的算术运算
只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为`difference_type`的带符号整型数。`string`和`vector`都定义了`difference_type`。


## 3.5 数组
数组是一种类似于`vector`的数据结构，与`vector`不同的地方是，数组的大小确定不变，不能随意向数组中添加元素。所以，如果不清楚元素的确切个数，建议使用`vector`。  

### 3.5.1 定义和初始化内置数组
定义数组的时候必须指定数组的类型，不允许用`auto`关键字由初始值的列表推断类型。和`vector`一样，数组的元素应为对象，因此不存在引用的数组。

#### 3.5.1.1  字符数组的特殊性
对于字符数组来说，我们可以用字符串字面值对该类数组初始化，此时需注意字符串字面值的结尾处还有一个空字符，该空字符也会像字符串的其它字符一样背靠背到字符数组中去。

#### 3.5.1.2 不允许拷贝和赋值
不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。

#### 3.5.1.3 理解复杂的数组声明
数组可以存放大多数类型的对象：
```cpp
int *ptrs[10]; //ptrs是含有10个整型指针的数组
int &refs[10] = ?  //错误不存在引用的数组
int (*Parray)[10] = &arr; //Parray指向一个含有10个整数的数组
int (&arrRef)[10] = arr; //arrRef引用一个含有10个整数的数组
int *(&arry)[10] = ptrs; //array是数组的引用，该数组含有10个指针
```
要理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。

### 3.5.2 访问数组元素
数组元素可以使用范围`for`语句或下标运算符来访问。在使用数组下标的时候，通常将其定义为`size_t`类型。`size_t`是一种机器相关的无符号类型，它被设计得足够大以便能够表示内存中任意对象的大小。在`cstddef`头文件中定义了`size_t`类型。

### 3.5.3 指针和数组
c++中数组和指针有非常紧密的联系，使用数组的时候编译器一般会把它转换成指针。  

对数组的元素使用取地址符(`&`)就能得到指向该元素的指针。在很多用到数组名字的地方，编译器都会自动将其替换成一个指向数组首元素的指针。`string *p2 = nums`等价于`p2 = &nums[0]`。 

可见，在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐含的意思，其中一层意思是当使用数组作为一个`auto`变量的初始值时，推断得到的类型是指针而非数组：
```cpp
int ia[] = {0,1,2,3,4,5,6,7,8,9};
auto ia2(ia); //ia2是一个整型指针，指向ia的第一个元素，该式等价于auto ia2(&ia[0])
ia2 = 42; //错误，ia2是一个指针，不能用int值给指针赋值
```
使用`decltype`关键字时上述转换不会发生，`decltype(ia)`返回的类型是由10个整数构成的数组：
```cpp
string nums[] = ["one","two","three"];
string *p = nums;
decltype ia[] = {0,1,2,3,4,5,6,7,8,9}; //ia3是一个含有10个整数的数组
ia3 = *p; //错误，不能用整型指针给数组赋值
```

#### 3.5.3.1 指针也是迭代器
指针支持`vector`和`string`迭代器支持的所有运算，此外，指针允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上。  

使用递增运算符遍历数组需获取数组的尾元素之后那个并不存在的元素的地址：
```cpp
int arr[] = {0,1,2,3,4,5,6,7,8,9};
int *e = &arr[10];
for (int *b = arr; b != e; ++b)
    cout << *b << endl;
```

#### 3.5.3.2 标准库函数begin和end
C++11新标准引入了两个名为`begin`和`end`的函数（注意与容器中的两个同名成员区分开）。这两个函数需要将数组作为他们的参数。`begin`函数返回指向数组首元素的指针，`end`函数返回指向数组尾元素下一位置的指针，这两个函数定义在`iterator`头文件中。
```cpp
int ia[] = {0,1,2,3,4,5,6,7,8,9};
int *beg = begin(ia)；
int *last = end(ia);
```
需注意的是，尾后指针不能指向解引用和递增操作。

#### 3.5.3.3 指针运算
指针能进行所有迭代器的运算且意义完全一致。  

两个指针相减的结果是它们之间的距离，参与运算的两个指针必须指向同一个数组当中的元素。两个指针相减的结果的类型是一种名为`ptrdiff_t`的带符号标准库类型，是一种定义在`cstddef`头文件中的机器相关的类型。

#### 3.5.3.4 下标和指针
标准库类型限定使用的下标必须是无符号类型，而内置的下标运算没有该要求。内置的下标运算符可以处理负值，但结果地址必须指向原来指针所指的同一数组的元素（或是同意数组尾元素的下一位置）
```cpp
int *p = &ia[2];
int k = p[-2]; //p[-2]是ia[0]表示的那个元素
```

### 3.5.4 C风格字符串
C风格字符串存放在字符数组中并以空字符(`'\0'`)结束。一般利用指针来操作这些字符串。

#### 3.5.4.1 C标准库String函数
下面是C语言标准库提供的一组函数，这些函数可用于操作C风格字符串，它们定义在`cstring`头文件中。
| 函数 | 说明 |
| :-: | :-: |
| `strlen(p)` | 返回`p`的长度，空字符不计算在内 |
| `strcmp(p1, p2)` |  比较`p1`和`p2`的相等性，如果`p1 == p2`，返回`0`；如果`p1 > p2`，返回一个正值；如果`p1 < p2`，返回一个负值 |
| `strcat(p1, p2)` | 将`p2`附加到`p1`之后，返回`p1` |
| `strcpy(p1, p2)` | 将`p2`拷贝给`p1`，返回`p1` |

传入此类函数的指针必须指向以空字符作为结束的数组!!!

#### 3.5.4.2 比较字符串
C风格字符串不能使用普通的关系运算符和相等性运算符，上述两者比较的将是指针而非字符串本身。  
要想比较两个C风格字符串需要调用`strcmp`函数。

### 3.5.4.3 目标字符串的大小由调用者指定
连接和拷贝C风格字符串需要使用`strcat`和`strcpy`函数，且使用这两个函数必须提供一个用于存放结果字符串的数组，该数组必须足够大以便容纳下结果字符串及末尾的空字符。

### 3.5.5 与旧代码的接口
#### 3.5.5.1 混用string对象和C风格字符串
任何出现字符串字面值的地方都可以用以空字符结束的字符数组来代替：
- 允许使用以空字符结束的字符数组来初始化`string`对象或为`string`对象赋值
- 在`string`对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在`string`对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象

不能使用`string`对象直接初始化指向字符的指针，但可以使用`c_str`成员函数进行初始化：
```cpp
string s("hello world");
char *str = s; //错误，不能用string对象初始化char*
const char *str = s.c_str();
```
`c_str`函数的返回值是一个C风格的字符串，函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组。结果指针的类型是`const char*`。如果后续的操作改变了`s`的值就可能让之前返回的数组失去效用。

#### 3.5.5.2 使用数组初始化vector对象
c++允许使用数组来初始化`vector`对象，但需要指明要拷贝区域的首元素地址和尾后地址：
```cpp
int int_arr[] = {0,1,2,3,4,5};
vector<int> ivec(begin(int_arr), end(int_arr));
vector<int> subVec(int_arr + 1, int_arr + 4);
```

## 3.6 多维数组
通常所说的多维数组其实是数组的数组。

### 3.6.1 多维数组的初始化
允许使用花括号括起来的一组值初始化多维数组。
```cpp
int ia[3][4] = {
  {0,1,2,3},
  {4,5,6,7},
  {8,9,10,11}
};
```
上述表达式等价于`int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};`  

同样的，多维数组仍可初始化部分元素：`int ia[3][4] = {{0},{4},{8}};`。该表达式仅初始化每一行的第一个元素，其他未列出的怨怒是执行默认初始化。

### 3.6.2 使用范围for语句处理多维数组
```cpp
size_t cnt = 0;
for (auto &row : ia)
    for (auto &col : row){
        col = cnt;
        ++cnt;
    }
```
**要使用范围`for`语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型，这是为了避免数组被自动转成指针。**

### 3.6.3 指针和多维数组
当程序使用多维数组的名字时，会自动将其转换成指向数组首元素的指针。因为多维数组实际上是数组的数组，所以由多维数组名转换的来的指针实际上是指向第一个内层数组的指针。  

C++新标准中，可以使用`auto`或者`decltype`避免在数组前面加上一个指针类型：
```cpp
int ia[3][4];
//输出ia中每个元素的值，每个内层数组各占一行
//p指向含有4个整数的数组
for (auto p = ia; p != ia + 3; ++p){
  //q指向4个整数数组的首元素
  for (auto q = *p; q != *p + 4; ++q)
    cout << *q << ' ';
  cout << endl;
}
//-----------------------
for (auto p = begin(ia); p != end(ia); ++p){
  for (auto q = begin(*p); q != end(*p); ++q)
    cout << *q << ' ';
  cout << endl;
}
```

### 3.6.5 类型别名简化多维数组的指针
```cpp
using int_array = int[4];//新标准下类型别名的声明
typedef int int_array[4];//等价的typedef声明

for (int_array *p = ia; p != ia + 3; ++p)
{
  for (int *q = *p; q != *p + 4; ++q)
    cout << *q << ' ';
  cout << endl;
}
```


# 第四章 表达式
## 4.1 基础
### 4.1.1 基本概念
- 一元运算符
- 二元运算符
- 三元运算符
- 重载运算符

#### 4.1.1.1 左值和右值
当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

- 赋值运算符需要一个（非常量）左值作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。
- 内置解引用运算符、下标运算符、迭代器解引用运算符、`string`和`vector`的下标运算符的求值结果都是左值。
- 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值。

使用关键字`decltype`的时候，左值和右值也有所不同。如果表达式的求值结果是左值，`decltype`作用于与该表达式（不是变量）得到一个引用类型。

### 4.1.2 优先级和结合律

### 4.1.3 求值顺序
有4种运算符明确规定了运算对象的求值顺序。
- 逻辑与(`&&`)运算符
- 逻辑或(`||`)运算符
- 条件(`?:`)运算符
- 逗号(`,`)运算符

## 4.2 算术运算符
下表是算数运算符（左结合律）
| 运算符 | 功能 | 用法 |
| :-: | :-: | :-: |
| `+` | 一元正号 | `+ expr` |
| `-` | 一元负号 | `- expr` |
| `*` | 乘法 | `expr * expr` |
| `/` | 除法 | `expr / expr` |
| `%` | 求余 | `expr % expr` |
| `+` | 加法 | `expr + expr` |
| `-` | 减法 | `expr - expr` |

4.3 逻辑和关系运算符
下表是逻辑运算符和关系运算符
| 结合律 | 运算符 | 功能 | 用法 |
| :-: | :-: | :-: | :-: |
| 右 | `!` | 逻辑非 | `!expr` |
| 左 | `<` | 小于 | `expr < expr` |
| 左 | `<=` | 小于等于 | `expr <= expr` |
| 左 | `>` | 大于 | `expr > expr` |
| 左 | `>=` | 大于等于 | `expr >= expr` |
| 左 | `==` | 相等 | `expr == expr` |
| 左 | `!=` | 不相等 | `expr != expr` |
| 左 | `&&` | 逻辑与 | `expr && expr` |
| 左 | `||` | 逻辑或 | `expr || expr` |

## 4.4 赋值运算符
- 赋值运算符满足右结合律
- 对于多重赋值语句的每一个对象，它的类型或者与右边的类型相同、或者可由右边对象的类型转换得到
- 赋值运算符优先级最低

## 4.5 递增和递减运算符
需注意，大部分运算符都没有规定运算对象的求值顺序，因此如果一条子表达式改变了某个运算对象的值，另一条子表达式又要使用该值将会对结果产生影响：
```cpp
while (beg != s.end() && !isspace(*beg))
    *beg = toupper(*beg++) //错误，该赋值语句未定义
```
上述程序，赋值运算符左右两端的运算对象都用到了`beg`，并且右侧的运算对象还改变了`beg`的值，所以该赋值语句是未定义的，编译器可能按照下面任意一种思路处理该表达式：
```cpp
*beg = toupper(*beg);//如果先求左侧的值
*(beg + 1) = toupper(*beg);//如果先求右侧的值
```

## 4.6 成员访问运算符
点运算符和箭头运算符都可用于访问成员，其中点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式`ptr->mem`等价于`(*ptr).mem`。

## 4.7 条件运算符
条件运算符(`?:`)允许我们把简单的`if-else`逻辑嵌入到单个表达式当中，条件运算符按照如下形式使用：  
`cond ? expr1 : expr2;`  
条件运算符的执行过程是：首先求`cond`的值，如果条件为真则对`expr1`求值并返回该值，否则对`expr2`求值并返回该值。

## 4.8 位运算符
下标是位运算符(左结合律):
| 运算符 | 功能 | 用法 |
| :-: | :-: | :-: |
| `~` | 位求反 | `~ expr` |
| `<<` | 左移 | `expr1 << expr2` |
| `>>` | 右移| `expr1 >> expr2` |
| `&` | 位与 | `expr1 & expr2` |
| `^` | 位异或 | `expr1 ^ expr2` |
| `!` | 位或 | `expr1 | expr2` |

## 4.9 sizeof运算符
`sizeof`运算符返回一条表达式或一个类型名字所占的字节数，其所得的值是一个`size_t`类型。`sizeof`运算符的运算对象右两种形式：`sizeof (type)` 和 `sizeof epxr`。在第二种形式中，`sizeof`返回的是表达式结果类型的大小。
```cpp
Sales_data data, *p;
sizeof(Sales_data);//存储Sales_data类型的对象所占的空间大小
sizeof data;//data的类型的大小，即sizeof(Sales_data)
sizeof p;//指针所占的空间大小
sizeof *p;//p所指类型的空间大小，即sizeof(Sales_data)
sizeof data.revenue;//Sales_data的revenue成员对应类型的大小
```
`sizeof`运算符的结果部分地依赖于其作用的类型：
- 对`char`或者类型为`char`的表达式执行`sizeof`运算，结果得`1`
- 对引用类型执行`sizeof`运算得到被引用对象所占空间的大小
- 对指针执行`sizeof`运算得到指针本身所占空间的大小
- 对解引用指针执行`sizeof`运算得到指针指向的对象所占空间的大小，指针不需有效
- 对数组指向`sizeof`运算得到整个数组所占空间的大小，等价于对数组中所有元素个执行一次`sizeof`运算并将所得结果求和。注意，`sizeof`运算不会把数组转换成指针来处理
- 将`string`对象或`vector`对象执行`sizeof`运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间

## 4.10 逗号运算符
逗号运算符含有两个运算对象，按照从左到右的顺序依次求值。对于逗号运算符来说，首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。

## 4.11 类型转换
在下面这些情况下，编译器将会自动地进行隐式类型转换：
- 在大多数表达式中，比`int`类型小的整数型首先提升为较大的整数类型
- 在条件中，非布尔值转换成布尔类型
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型
- 函数调用时会发生类型转换

### 4.11.1 算术转换
算数转换的规则定义了一套类型转换的层次，其中运算符的运算对象将转换成最宽的类型。

#### 4.11.1.1 整型提升
**整型提升** 负责把小整数类型转换成较大的整数类型。 

对于`bool`、`char`、`signed char`、`unsigned char`、`short`和`unsigned short`等类型来说，只要它们所有可能的值都能存在`int`里，它们就会提升成`int`类型；否则提升成`unsigned int`类型。

较大的`char`类型（`wchar_t`、`char16_t`、`char32_t`）提升成`int`、`unsigned int`、`long`、`unsigned long`、`long long`和`unsigned long long`中最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。

#### 4.11.1.2 无符号类型的运算对象
类型转化过程，首先执行整型提升。如果结果的类型匹配，无须进行进一步的转换。如果两个（提升后的）的运算对象的类型要么是都是带符号的、要么都是无符号的，则小类型运算对象转换成较大的类型。

如果两个个运算对象分别是无符号类型和带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。

如果带符号类型大于无符号类型，此时转换的结果依赖于机器。如果无符号类型的所有制都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。

### 4.11.2 其他隐式类型转换
除了算数转换之外还油几种隐式类型转换，包括：
- 数组转换成指针  
  在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。但当数组被用作`decltype`关键字的参数，或者作为取地址符(`&`)、`sizeof`及`typeid`等运算符的运算对象时，上述转换不会发生。如果用一个引用来初始化数组时，转换也不会发生。
- 指针的转换
  - 常量整数值`0`或字面值`nullptr`能转换成任意指针类型
  - 指向任意非常量的指针能转换成`void*`
  - 指向任意对象的指针能转换成`const void*`
- 转换成布尔类型
  - 如果指针或算术类型的值为`0`，转换结果为`false`；否则为`true`
- 转换成常量
  - 允许将非常量类型的指针转换成指向相应的常量类型的指针。
- 类类型定义的转换
  - 类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换。

### 4.11.3 显示转换
#### 4.11.3.1 命名的强制类型转换
一种命名的强制类型转换具有如下形式：`cast-name<type>(expresssion);`。  
其中`type`是转换的目标类型，而`expression`是要转换的值。`case-name`指定了执行的是哪种转换，是`static_cast`、`dynamic_cast`、`const_cast`和`reinterpret_cast`中的一种。

- `static_cast`  
  任何具有明确定义的类型转换，只要不包含底层`const`，都可以使用`static_cast`。  

  当需要把一个较大的算术类型赋给较小的类型时，`static_cast`非常有用。此时，强制类型转换告诉程序的读者和编译器，我们知道并且不在乎潜在的精度损失。  

  `static_cast`对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用`static_cast`找回存在于`void*`指针中的值。
  ```cpp
  void* p = &d; //正确：任何非常量对象的地址都能存入void*
  double *dp  = static_cast<double*> (p); 
  ```

- `const_cast`   
  `const_cast`只能改变运算对象的底层`const`，不能改变表达式的类型。`const_cast`常常用于有函数重载的上下文中。

- `reinterpret_cast`  
  `reinterpret_cast`通常为运算对象的位模式提供较低层次上的重新解释。

  例如，假设有如下的转换：
  ```cpp
  int *ip;
  char *pc = reinterpret_cast<char*>(ip);
  ```
  我们必须牢记`pc`所指的真实对象是一个`int`而非字符，如果把`pc`当作普通的字符指针使用可能在运行时发生错误。例如：`string str(pc);`。可能导致异常的运行时行为。

  使用`reinterpret_cast`是非常危险的。其中的关键问题是类型改变了，但编译器没有给出任何警告或者错误的提示信息。当我们用一个`int`的地址初始化pc时，由于显式地声明这种转换合法，所以编译器不会给出任何警告或错误信息。接下来再使用`pc`时就会认定它的值是`char*`类型，编译器没法知道它实际存放的是指向`int`的指针。

#### 4.11.3.2 旧式的强制类型转换
在早期版本的C++语言中，显式地进行强制类型转换包含两种形式：
```cpp
type (expr);  //函数形式的强制类型转换
(type) expr;  //C语言风格的强制类型转换
```
根据所涉及的类型不同，旧式的强制类型转换分别与`const_cast`、`static_cast`或`reinterpret_cast`相似的行为。当我们在某处执行旧式的强制类型转换时，如果换成`const_cast`和`static_cast`合法，则其行为与对应的命名转换一致，否则其执行与`reinterpret_cast`类似。

## 4.12 运算符优先级表
| 结合律 | 运算符 | 功能 | 用法 |
| :-: | :-: | :-: | :-: |
| 左 | `::` | 全局作用域 | `::name` |
| 左 | `::` | 类作用域 | `class::name` |
| 左 | `::` | 命名空间作用域 | `namespace::name` |
| - | - | - | - |
| 左 | `.` | 成员选择 | `object.member` |
| 左 | `->` | 成员选择 | `pointer->member` |
| 左 | `[]` | 下标 | `epxr1[expr2]` |
| 左 | `()` | 函数调用 | `name(expr_list)` |
| 左 | `()` | 函数构造 | `type(epxr_list)` |
| - | - | - | - |
| 右 | `++` | 后置递增运算 | `Ivalue++` |
| 右 | `--` | 后置递减运算 | `Ivalue--` |
| 右 | `typeid` | 类型ID | `typeid(type)` |
| 右 | `typeid` | 运行时类型ID | `typeid(expr)` |
| 右 | `explicit cast` | 类型转换 | `cast_name<type>(expr)` |
| - | - | - | - |
| 右 | `++` | 前置递增运算 | `++Ivalue` |
| 右 | `--` | 前置递减运算 | `--Ivalue` |
| 右 | `~` | 位求反 | `~expr` |
| 右 | `!` | 逻辑非 | `!expr` |
| 右 | `-` | 一元负号 | `-expr` |
| 右 | `+` | 一元正号 | `+expr` |
| 右 | `*` | 解引用 | `*expr` |
| 右 | `&` | 取地址 | `&expr` |
| 右 | `()` | 类型转换 | `(type)expr` |
| 右 | `sizeof` | 对象大小 | `sizeof expr` |
| 右 | `sizeof` | 类型的大小 | `sizeof(type)` |
| 右 | `Sizeof...` | 参数包的大小 | `Sizeof...(name)` |
| 右 | `new` | 创建对象 | `new type` |
| 右 | `new[]` | 创建数组 | `new type[size]` |
| 右 | `delete` | 释放对象 | `delete expr` |
| 右 | `delete[]` | 释放数组 | `delete[] expr` |
| 右 | `noexcept` | 是否抛出异常 | `noexcept(expr)` |
| - | - | - | - |
| 左 | `->*` | 指向成员选择的指针 | `ptr->ptr_to_member` |
| 左 | `.*` | 指向成员选择的指针 | `ptr.ptr_to_member` |
| - | - | - | - |
| 左 | `*` | 乘法 | `expr1 * expr2` |
| 左 | `/` | 除法 | `expr1 / expr2` |
| 左 | `%` | 取模（取余） | `expr1 % expr2` |
| - | - | - | - |
| 左 | `+` | 加法 | `expr1 + expr2` |
| 左 | `-` | 减法 | `expr1 - expr2` |
| - | - | - | - |
| 左 | `<<` | 向左移位 | `expr1 << expr2` |
| 左 | `>>` | 向右移位 | `expr1 >> expr2` |
| - | - | - | - |
| 左 | `<` | 小于 | `expr1 < expr2` |
| 左 | `<=` | 小于等于 | `expr1 <= expr2` |
| 左 | `>` | 大于 | `expr1 > expr2` |
| 左 | `>=` | 大于等于 | `expr1 >= expr2` |
| - | - | - | - |
| 左 | `==` | 相等 | `expr1 == expr2` |
| 左 | `!=` | 不等 | `expr1 != expr2` |
| - | - | - | - |
| 左 | `&` | 位与 | `expr1 & expr2` |
| - | - | - | - |
| 左 | `^` | 位异或 | `expr1 ^ expr2` |
| - | - | - | - |
| 左 | `|` | 位或 | `expr1 | expr2` |
| - | - | - | - |
| 左 | `&&` | 逻辑与 | `expr1 && expr2` |
| - | - | - | - |
| 左 | `||` | 逻辑或 | `expr1 || expr2` |
| - | - | - | - |
| 右 | `?:` | 条件 | `condition ? expr1 : expr2` |
| - | - | - | - |
| 右 | `=` | 赋值 | `Ivalue = expr` |
| - | - | - | - |
| 右 | `*=、/=、%=` | 复合赋值 | `Ivalue += expr`等 |
| 右 | `+=、-=` |  |  |
| 右 | `<<=、>>=` |  |  |
| 右 | `&=、!=、^=` |  |  |
| - | - | - | - |
| 右 | `throw` | 抛出异常 | `throw expr` |
| - | - | - | - |
| 左 | `,` | 逗号 | `expr, expr` |


# 第五章 语句
## 5.1 简单语句
- 空语句  
  使用空语句时应该加上注释，从而令读该段代码的人知道该语句是有意省略的

- 别漏写分号，也别多写分号  
  多余的空语句并非总是无害的

- 复合语句（块）  
  复合语句是指用花括号括起来的（可能为空）语句和声明的序列，复合语句也被称为块。块不以分号作为结束。


## 5.2 语句作用域

## 5.3 条件语句
### 5.3.1 if语句
```cpp
//形式1
if (condition)
    statement;
//形式2
if (condition) 
    statement1;
else
    statement2;
```
- 悬垂`else`  
  对于C++来说，当`if`分支多于`else`分支时，规定`else`与离它最近的尚未匹配的`if`匹配。
  ```cpp
  if (grade % 10 >= 3)
      if (grade % 10 > 7)
            lettergrade += '+';
  else 
      lettergrade += '+';//末尾是3，4，5，6，7的成绩加一个减号！
  ```

### 5.3.2 switch语句
- `case`标签必须是整型常量表达式
- 一般不要省略`case`分支最后的`break`语句，如果没写`break`语句，最好加上一段注释说明程序的逻辑
- 尽管`switch`语句不是非得在最后一个标签后面写上`break`，但是为了安全起见，最好这样做。因为这样的话，即使以后再增加新的`case`分支，也不要再在前面补充`break`语句。
- 即使不准备在`default` 标签下做任何工作，定义一个`default`标签也是有用的。其目的在于告诉程序的读者，我们已经考虑到了默认的情况，只是目前什么也没有做。

#### 5.3.2.1 switch内部的变量定义
如果在某处一个带有初值的变量位与作用域之外，在另一处该变量位与作用域之内，则从前一处跳转到后一处的行为是非法行为：
```cpp
case true:
  //因为程序的执行流程可能绕开下面的初始化语句，所以该switch语句不合法
  string file_name;  //错误：控制流绕开一个隐式初始化的变量
  int jval = 0; //错误：控制流绕开一个显式初始化的变量
  int jval; //正确：因为jval没有初始化
  break;
case false:
  //正确:jval虽然在作用域内，但是它没有被初始化
  jval = next_num(); //正确：给jval赋值
  if (file_name.empty()) //file_name在作用域内，但是没有被初始化
    //...
```
假设上述代码合法，则一旦控制流直接跳到`false`分支，也就同时略过了变量`file_name`和`ival`的初始化过程。此时这两个变量位于作用域之内，跟在`false`之后的代码试图在尚未初始化的情况下使用它们，这是错误的。因此C++语言规定，不允许跨国变量的初始化语句直接跳转到该变量作用域内的另一个位置。

如果需要为某个`case`分支定义并初始化一个变量，我们应该把变量定义在块内，从而确保后面的所有`case`标签都在变量的作用域之外。
```cpp
case true:
  {
    //正确：声明语句在语句块内部
    string file_name = get_file_name();
    //...
  }
  break;
case false:
  if (file_name.empty()) //错误：file_name不在作用域之内
```

## 5.4 迭代语句
### 5.4.1 while语句
```cpp
while (condition)
    statement;
```

### 5.4.2 传统的for语句
```cpp
for (initializer;condition;expression)
    statement;
```

### 5.4.3 范围for语句
```
for (declaration : expression)
    statement;
```
`expression`表示的必须是一个序列，`declaration`定义一个变量，序列中的每个元素都能转换成该变量的类型。
```cpp
for (auto &r : v)
{
  r *= 2;
} 
```
范围`for`语句的定义来源于与之等价的传统`for`语句：
```cpp
for (auto beg = v.begin(), end = v.end(); beg != end; ++beg)
{
  auto &r = *beg;
  r *= 2;
}
```
在范围`for`语句中，预存了`end()`的值，一旦在序列中添加（删除）元素，`end`函数的值就可能变得无效。

### 5.4.4 do while语句
```cpp
do  
    statement;
while (condition);
```
在`do`语句中，求`condition`的值之前首先执行一次`statement`，`condition`不能为空。

## 5.5 跳转语句
### 5.5.1 break语句
`break`语句负责终止离它最近的`while`、`do while`、`for`或`switch`语句，并从这些语句之后的第一条语句开始继续执行。

### 5.5.2 continue语句
`continue`语句终止最近的循环中的当前迭代并立即开始下一次迭代。`continue`语句只能出现在`for`、`while`和`do while`循环的内部，或者嵌套在此类循环里的语句或块的内部。

### 5.5.3 goto语句
`goto`语句的作用是从`goto`语句无条件跳转到同一函数内的另一条语句。`goto`语句的语法形式是：`goto label`。其中`label`是用于标识一条语句的标示符。`goto`语句和控制权转向的那条带标签的语句必须位于同一个函数之内。

## 5.6 try语句块和异常处理
异常处理机制为程序中异常检测和异常处理这两部分的写作提供支持。在C++语言中，异常处理包括：
- `throw`表达式  
  异常检测部分使用`throw`表达式来表示它遇到了无法处理的问题。`throw`引发了异常。
- `try`语句块
  异常处理部分使用`try`语句块处理异常。`try`语句块以关键字`try`开始，并以一个或多个`catch`字句结束。`try`语句块中抛出的异常通常会被某个`catch`字句（**异常处理代码块**）处理。
- 一套 **异常类**，用于在`throw`表达式和相关的`catch`字句之间传递异常的具体信息

### 5.6.1 throw表达式
程序的异常检查部分使用`throw`表达式引发一个异常。`throw`表达式包含关键字`throw`和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。

### 5.6.2 try语句块
```cpp
try {
  program-statements;
} catch (exception-declaration) {
  handler-statements;
} catch (exception-declaration) {
  handler-statements;
} //...
```

### 5.6.3 标准异常
C++标准库定义了一组类，用于报告标准库函数遇到的问题。这类异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中：
- `exception`头文件定义了最通用的异常类`exception`。它只报告异常的发生，不提供任何额外信息。
- `stdexcept`头文件定义了几种常用的异常类
  | 异常类 | 说明 |
  | :-: | :-: |
  | `exception` | 最常见的问题 |
  | `runtime_error` | 只有在运行时才能检测出的问题 |
  | `range_error` | 运行时错误：生成的结果超出了有意义的值域范围 |
  | `overflow_error` | 运行时错误：计算上溢 |
  | `underflow_error` | 运行时错误，计算下溢 |
  | `logic_error` | 程序逻辑错误 |
  | `domain_error` | 逻辑错误：参数对应的结果值不存在 |
  | `invalid_argument` | 逻辑错误：无效参数 |
  | `length_error` | 逻辑错误：试图创建一个超出该类型最大长度的对象 |
  | `out_of_range` | 逻辑错误：使用一个超出有效范围的值 |
- `new`头文件定义了`bad_alloc`异常类型
- `type_info`头文件定义了`bad_cast`异常类型


# 第六章 函数
## 6.1 函数基础
- 实参和形参
- 函数的返回类型

### 6.1.1 局部对象
形参和函数体内定义的变量统称为 **局部变量**。局部变量会隐藏在外层作用域中同名的其他所有声明。

#### 6.1.1.1 自动对象
只存在于执行期间的对象称为 **自动对象**。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。

#### 6.1.1.2 局部静态对象
**局部静态对象** 在程序执行路径第一次经过对象定义语句时初始化，并且知道程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。
```cpp
size_t count_calls()
{
  static size_t ctr = 0;//调用结束后，这个值仍然有效
  return ++ctr;
}
int main()
{
  //输出从1到10的所有数字
  for (size_t i = 0; i != 10; ++i)
      cout << cout_calls() << endl;
  return 0;
}
```

### 6.1.2 函数声明
函数名字必须在使用之前声明函数，函数只能定义一次，但可以声明多次。函数声明(也称为函数原型)需包括函数三要素(返回类型、函数名、形参类型)。函数三要素描述了函数的接口，说明了调用该函数所需的全部信息。

### 6.1.3 分离式编译

## 6.2 参数传递
- 当形参是引用类型时，我们说它对应的实参被引用传递或者函数被传引用调用。
- 当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被值传递或者函数被传值调用。

### 6.2.1 传值参数
通过指针间接地访问它所指的对象（使用`*`），可以修改他所指对象的值。若只是改变指针的拷贝对象，则指向的对象不受影响。
```cpp
void reset(int *ip)
{
  *ip = 0;//改变指针ip所指对象的值
  ip = 0;//只改变了ip的局部拷贝，实参未被改变
}
```

### 6.2.2 传引用参数
- 使用引用避免拷贝  
  拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。  
  如果函数无需改变引用形参的值，最好将其声明为常量引用。

- 使用引用形参返回额外信息
  引用形参为我们一次返回多个多个结果提供了有效的途径。例如，定义一个名为`find_char`的函数，它返回在`string`对象中某个指定字符第一次出现的位置。同时希望该函数能返回该字符出现的次数。
  ```cpp
  //返回s中c第一次出现的位置索引
  //返回形参occurs负责统计c出现的总次数
  string::size_type find_char(const string &s, char c, string::size_type &occurs)
  {
    auto ret = s.size(); //第一次出现的位置
    occurs = 0; //设置表示出现次数的形参的值
    for (decltype(ret) i = 0; i != s.size(); ++i)
    {
      if (s[i] == c)
      {
        if (ret == s.size())
          ret = i; //记录c第一次出现的位置
        ++occurs; //将出现的次数加1
      }
    }
    return ret;  //出现次数通过occurs隐式地返回
  }
  ```

### 6.2.3 const形参和实参
当用实参初始化形参时，会忽略掉顶层`const`。

使用引用而非常量引用会较大地限制函数所能接受的实参类型。我们不能把`const`对象、字面值或者需要类型转换的对象传给普通的引用形参。

### 6.2.4 数组形参
数组的两个特殊性质对我们定义和作用在数组上的函数有影响，这两个性质分别是：
- 不允许拷贝数组  
  因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。
- 使用数组时（通常）会转换成指针。  
  因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。
```cpp
//每一个函数都有一个const int*类型的形参
void print(const int*);
void print(const int[]); //可以看出来，函数的意图是作用作用于一个数组
void print(const int[10]); //这里的维度表示我们期望数组含有多少元素，实际不一定（因为实参自动转换成指向数组首元素的指针，数组的大小对函数的调用没有影响）
```

#### 6.2.4.1 使用标准库规范
传递指向数组首元素和尾后元素的指针可以用来管理数组实参。
```cpp
void print(const int *beg, const int *end)
{
  ...
  while(beg != end)
    cout << *beg++ << endl;
}
```

#### 6.2.4.2 数组引用形参
```cpp
void print(int (&arr)[10])
{
  for (auto elem : arr)
    cout << elem << endl;
}
```
> `&arr`两端的括号必不可少
> ```cpp
> f(int &arr[10]) //错误，将arr声明成了引用的数组
> f(int (&arr)[10]) //正确：arr是具有10个整数的整型数组的引用
> ```

#### 6.2.4.3 传递多维数组
当讲多维数组传递给函数时，真正传递的是指向数组首元素的指针。`void print(int (*matrix)[10], int rowsize)`。

若使用数组的语法定义函数，此时编译器会忽略掉第一个维度，所以最好不要把它包含在形参列表内。

### 6.2.5 main：处理命令行选项
有时我们需要给`main`传递实参，一种常见的情况是用户通过设置一组选项来确定函数索要执行的操作。例如，假设`main`函数位于可执行文件`prog`之内，我们可以向程序传递下面的选项：
```cpp
prog -d -o ofile data0
```
这个命令行选项通过两个（可选的）形参传递给`main`函数：
```cpp
int main(int agrc, char *argv[]) { ... }
//或者
int main(int agrc, char **argv) { ... }
```
第二个形参`argv`是一个数组，它的元素是指向C风格字符串的指针；第一个形参`argc`表示数组中字符串的数量。

当实参传给`main`函数之后，`argv`的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为`0`。

### 6.2.6 含有可变形参的函数
为了编写能处理不同数量实参的函数，C++新标准提供了两种主要的办法：
- 如果所有的实参类型相同，可以传递一个名为`initializer_list`的标准库类型；
- 如果实参的类型不同，我们可以编写一种特殊的函数：可变参数模板

C++还有一种特殊的形参类型（省略符），可以用它传递可变数量的实参。但这种功能一般只适用于与C函数交互的接口程序。

#### 6.2.6.1 initializer_list形参
`initializer_list`是一种标准库类型，用于表示某种特定类型的值的数组。`initializer_list`类型定义在同名的头文件中，它提供的操作如下表：
| 操作 | 说明 |
| :-: | :-: |
| `initializer_list <T> lst` | 默认初始化，`T`类型元素的空列表 |
| `initializer_list <T> lst{a,b,c...}` | `lst`的元素数量和初始值一样多；`lst`的元素是对应初始值的副本；列表中的元素是`const` |
| `lst2(lst)`  | 拷贝或赋值一个`initializer_list`对象，不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素 |
| `lst2 = lst` | 同`lst2()lst` |
| `lst.size()` | 列表中的元素数量 |
| `lst.begin()` | 返回指向`lst`中首元素的指针 |
| `lst.end()` | 返回指向`lst`中尾元素下一位置的指针 |

`initializer_list`对象中的元素永远是常量值，我们无法改变`initializer_list`对象中元素的值。

我们使用如下的形式编写输出错误信息的函数，使其可以作用于可变数量的实参：
```cpp
void error_msg(initializer_list<string> il)
{
  for (auto beg = il.begin(); beg != il.end(); ++beg)
      cout << *beg << " ";
  cout << endl;
}
```

#### 6.2.6.2 省略符形参
省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为`varargs`的C标准库功能。通常，省略符形参不应用于其他目的。

省略符形参只能出现在形参列表的最后一个位置，它的形式有以下两种：
```cpp
void foo(parm_list, ...);
void foo(...);
```

## 6.3 返回类型和return语句
`return`语句终止当前正在执行的函数并将控制权返回到调用函数的地方。

### 6.3.1 无返回值函数
没有返回值的`return`语句只能用在返回类型是`void`的函数中。返回`void`的函数不要求非得有`return`语句，因为在这类函数的最后依据后面会隐式地执行`return`。

一个返回类型是`void`的函数也能使用`return exprssion`语句，不过此时`return`语句的`expression`必须是另一个返回`void`的函数。

### 6.3.2 有返回值函数
`return expression`语句提供了函数的结果。只要函数的返回类型不是`void`，则该函数内的每条`return`语句必须返回一个值。`return`语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。
> 在含有`return`语句的循环后面应该也有一条`return`语句，如果没有的话该程序就是错误的。很多编译器都无法发现此类错误。

#### 6.3.2.1 值是如何被返回的
返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时值，该临时量就是函数调用的结果。

#### 6.3.2.2 不要返回局部对象的引用或指针
函数完成后，它所占用的存储空间也随之被释放掉，因此，函数终止意味着局部变量的引用将指向不再有效的内存区域：
```cpp
//严重错误：这个函数试图返回局部对象的引用
const string &manip()
{
  string ret;
  //以某种方式改变一下ret
  if (!ret.empty())
      return ret;   //错误：返回局部对象的引用！
  else
      return "Empty"; //错误：“empty”是一个局部临时量
}
```
事实上还是看该地址的位置是否在该函数的栈区，若是在栈区，函数调用结束，该地址就被释放了。尽管会出现栈地址上的值没被销毁的问题，可能是该栈区还没被其他的函数堆栈掉。

#### 6.3.2.3 列表初始化返回值
C++新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。
```cpp
vector<string> process()
{
  //...
  if (expected.empty())
    return {};
  else if (expected == actual)
    return {"functionX", "okey"};
  else
    return {"functionX", expected, actual};
}
```

#### 6.3.2.4 主函数main的返回值
我们允许`main`函数没有`return`语句直接结束。如果控制到达了`main`函数的结尾处而且没有`return`语句，编译器讲隐式地插入一条返回 0 的`return`语句。

`main`函数的返回值可以看做是状态指示器。返回0表示执行成功，返回其他值表示执行失败，其中非0值的具体含义依机器而定。为了使返回值与机器无关，`cstdlib`头文件定义了两个预处理变量，我们可以使用这两个变量分别表示成功与失败。
```cpp
int main()
{
  if (some_failure)
    return EXIT_FAILURE;
  else
    return EXIT_SUCCESS;
}
```

### 6.3.3 返回数组指针
因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。最直接的方式是通过使用类型别名实现该任务：
```cpp
//arrT是一个类型别名，它表示的类型是含有10个整数的数组
typedef int arrT[10];
using arrT = int[10];
arrT* func(int);
```

若不使用类型别名，需要牢记被定义的名字后面的数组的维度。返回数组指针的函数类型如下所示：
```cpp
Type (*function(parameter_list))[dimension]
```

#### 6.3.3.1 使用尾置返回类型
在C++新标准种有一种简化函数声明的方法，即使用 **尾置返回类型**。任何函数的定义都能使用位置返回，但是这种类型对于返回类型比较复杂的函数最有效。尾置返回类型跟在形参列表后面并以一个`->`符号开头。为了表示函数真正返回类型跟在形参之后，我们在本应该出现返回类型的地方放置一个`auto`：
```cpp
//func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组
auto func(int i) -> int(*) [10];
```

#### 6.3.3.2 使用decltype
如果我们知道函数返回的指针将指向哪个数组，就可以使用`decltype`关键字声明返回类型。
```cpp
int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};
//返回一个指针，该指针指向含有5个整数的数组
decltype(odd) *arrPtr(int i)
{
  return (i % 2) ? &odd : &even; //返回一个指向数组的指针
}
```
`arrPtr`使用关键字`decltype`表示它的返回类型是个指针，并且该指针所指的对象与`odd`的类型一致。因为`odd`是数组，所以`arrPtr`返回一个指向含有5个整数的数组的指针。需注意的是：`decltype`并不负责把数组类型转换成对应的指针，所以`decltype`的结果是个数组，要想表达`arrPtr`返回指针还必须在函数声明时加上一个`*`符号。

## 6.4 函数重载
如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为 **重载函数**。

#### 重载和const形参
一个拥有顶层`const`的形参无法和另一个没有顶层`const`的形参区分开来。

如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的`const`是底层的。

#### const_cast和重载
```cpp
const string &shorterString(const string &s1, const string &s2)
{
  return s1.size() <= s2.size() ? s1 : s2;
}
```
这个函数的参数和返回类型都是`const string`的引用。我们可以对两个非常量的`string`实参调用这个函数，但返回的结果仍然是`const string`的引用。使用`const_cast`，可以使当它的实参不是常量时，得到的结果是一个普通的引用：
```cpp
const string &shorterString(string &s1, string &s2)
{
  auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
  return const_const<string&>(r);
}
```
上述函数中，首先将它的实参强制转换成对`const`的引用，然后调用了`shorterString`函数的`const`版本，该版本返回对`const string`的引用，这个引用事实上绑定了在某个初始的非常量实参上，因此我们可以再将其转换回一个普通的`string&`。

## 6.5 特殊用途语言特性
### 6.5.1 默认实参
某个函数有这一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的 **默认实参**。调用含有默认实参的函数时，可以包含该实参，也可以忽略该实参。
```cpp
typedef string::size_type sz;
string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');
```
我们可以为一个或多个形参定义默认值，不过需要注意的是，**一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。**

函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参（靠右位置）。
```cpp
window = screen(,, '?'); //错误：只能忽略尾部的实参
```
当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。

#### 6.5.1.1 默认实参声明
在给定的作用域中一个形参只能被赋予一次默认实参。函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须有默认值：
```cpp
typedef string::size_type sz;
string screen(sz, sz, char = ' ');
string screen(sz ,sz , char = '*');//错误：重复声明
string screen(sz = 24, sz = 80, char);
```

#### 6.5.1.2 默认实参初始值
局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参：
```cpp
typedef string::size_type sz;
sz wd = 80;
char def = ' ';
sz ht();
string screen(sz = ht(), sz = wd, char = def);
string window = screen();
```

### 6.5.2 内联函数和constexpr函数
内联函数可避免函数调用的开销。把函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开（等价替换）。在函数的返回类型前面加上关键字`inline`，就能将它声明成内联函数。

`constexpr`函数是指能用于常量表达式的函数。定义`constexpr`函数需要遵守以下规定：
- 函数的返回类型及所有形参的类型都得是字面值类型
- 函数体中必须有且只有一条`return`语句

`constexpr`函数体内也可以包含其他语句，只要这些语句在执行时不执行任何操作就行。

### 6.5.3 调试帮助
C++程序员会用到一种类似于头文件保护的技术，以便有选择地执行调试代码。基本思想是，程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：`assert`和`NDEBUG`。

#### 6.5.3.1 assert预处理宏
`assert`是一种预处理宏，即一个预处理变量，他的行为有点类似于内联函数。`assert`宏使用一个表达式作为它的条件：
```cpp
assert(expr);
```
首先对`expr`求值，如果表达式为假，`assert`输出信息并终止程序的执行。如果表达式为真，`assert`说明也不做。

`assert`宏定义在`cassert`头文件中。`assert`宏常用于检查“不能发生”的条件。

#### 6.5.3.2 NDEBUG预处理变量
`assert`的行为依赖于一个名为`NDEBUG`的预处理变量的状态。如果定义了`NDEBUG`，则`assert`什么也不做。默认状态下没有定义`NDEBUG`，此时`assert`将执行运行时检查。

我们可以使用一个`#define`语句定义`NDEBUG`，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量：
```
$ CC -D NDEBUG main.c 
```
定义`NDEBUG`能避免检查各种条件所需的运行时开销。`assert`应该仅用于验证哪些雀食不可能发生的事情。我们可以把`assert`当作调试程序的一种辅助手段，但是不能用它代替真正的运行时逻辑检查，也不能代替程序本身应该包含的错误检查。

可以使用`NDEBUG`编写自己的条件调试代码。如果`NDEBUG`未定义，将执行`ifndef`和`#endif`之间的代码；如果定义了`NDEBUG`，这些代码将被忽略掉：
```cpp
void print(const int ia[], size_t size)
{
#ifndef NDEBUG
    // _ _func_ _ 是编译器定义的一个局部静态变量，用于存放函数的名字
    cerr << _ _func_ _ << ": array size is " << size << endl;
#endif
//...
```
在上述代码中，我们使用变量`_ _func_ _`输出当前调试的函数的名字。编译器为每个函数都定义了`_ _func_ _`，它是`const char`的一个静态数组，用于存放函数的名字。

除了C++编译器定义的`_ _func_ _`之外，预处理器还定义了另外4个对于程序调试很有用的名字:
| 名字 | 说明 |
| :-: | :-: |
| `_ _FILE_ _` | 存放文件名的字符串字面值 |
| `_ _LINE_ _` | 存放当前行号的整型字面值 |
| `_ _TIME_ _` | 存放文件编译时间的字符串字面值 |
| `_ _DATE_ _` | 存放文件编译日期的字符串字面值 |

可以使用这些常量在错误消息中提供更多的信息：
```cpp
if (word.size() < threshold)
  cerr << "Error: " << _ _FILE_ _
    <<> ": in function " << _ _func_ _
    << "at line" << _ _LINE_ _ << endl
    << "    Compiled on " << _ _DATE_ _
    << " at " << _ _TIME_ _ << endl
    << "    Word read was \"" << word
    << "\": Length too short" << endl;
```

## 6.6 函数匹配
#### 确定候选函数和可行函数
函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数称为 **候选函数**。候选函数具有两个特征：
- 与被调用的函数同名
- 其声明在调用点可见

第二步是考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为 **可行函数**。可行函数有两个特征：
- 其形参数量与本次调用提供的实参数量相等
- 每个实参的类型与对应的形参类型相同，或者能转换成形参的类型

如果没找到可行函数，编译器将报告无匹配函数的错误。

#### 寻找最佳匹配（如果有的话）
函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。它的基本思想是，实参类型和形参类型越接近，它们匹配得越好。

### 6.6.1 实参类型转换
为了确定最佳匹配，编译器将实参类型的转换划分成几个等级，具体排序如下所示：
1. 精准匹配，包括以下情况
  - 实参类型和形参类型相同
  - 实参从数组类型或函数类型转换成对应的指针类型
  - 向实参添加顶层`const`或者从实参中删除顶层`const`
2. 通过`const`转换实现的匹配
3. 通过类型提升实现的匹配
4. 通过算术类型转换或指针转换实现的匹配
5. 通过类类型转换实现的匹配

## 6.7 函数指针
函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。

### 6.7.1 使用函数指针
当我们把函数名作为一个值使用时，该函数自动地转换成指针。
```cpp
bool lengthCompare(const string&, const string &);
//pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型
bool (*pf)(const string&, const string&);
pf = lengthCompare; //pf指向名为lengthCompare的函数
pf = &lengthCompare; //等价的赋值语句，取地址符是可选的
```
我们可以直接使用指向函数的指针调用该函数，无需提前解引用指针：
```cpp
bool b1 = pf("hello", "goodbye"); //调用lengthCompare函数
bool b2 = (*pf)("hello", "goodbye"); //一个等价的调用
bool b3 = lengthCompare("hello", "goodbye"); //另一个等价的调用
```
在指向不同函数类型的指针间不存在转换规则。

### 6.7.2 重载函数的指针
如果定义了指向重载函数的指针，指针类型必须与重载函数中的某一个精确匹配。
```cpp
void ff(int*);
void ff(unsigned int);
void (*pf1)(unsigned int) = ff;
```

### 6.7.3 函数指针形参
函数的形参可以是指向函数的指针，此时，形参看起来是函数类型，实际上被当作指针使用。

使用类型别名和`decltype`能让我们简化使用函数指针的代码：
```cpp
bool lengthCompare(const string&, const string &);
//Func和Func2是函数类型
typedef bool Func(const string&, const string&);
typedef decltype(lengthCompare) Func2; //等价的类型
//FuncP和FuncP2是指向函数的指针
typedef bool (*FuncP)(const string&, const string&);
typedef decltype(lengthCompare) *FuncP2;//等价的类型
```
需注意的是，`decltype`返回函数类型，此时不会将函数类型自动转换成指针类型。

### 6.7.4 返回指向函数的指针
可以返回指向函数类型的指针，但是我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。可以通过类型别名简化操作：
```cpp
using F = int(int*, int); //F是函数类型，不是指针
using PF = int(*)(int*, int); //PF是指针类型
```
由于返回类型不会自动地转换成指针，我们必须显式地将返回类型指定为指针：
```cpp
PF f1(int); //正确：PF是指向函数的指针，f1返回函数的指针
F f1(int); //错误：F是函数类型，f1不能返回一个函数函数
F *f1(int); //显式地指定返回类型是指向函数的指针
```
我们也可以用下面的形式直接声明`f1`:
```cpp
int (*f1(int))(int*, int);
```
也可以用尾置返回类型的方式声明一个返回函数指针的函数：
```cpp
auto f1(int) -> int (*)(int*, int);
```
